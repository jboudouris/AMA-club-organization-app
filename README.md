# AMA-club-organization-app
AMA Club App
Requirements and Specification Document
2019-02-09, version 1.0

# Project Abstract
Running a student club is a complicated process. As a result organizations often end up relying on many different applications.This disorganization leads to a need for a larger boardand difficulties planning events and managing administrative tasks. Ultimately these setbacks slow down and complicate the club’s operations. By addressing these issues and coming up with a solution the club would be able to streamline their operations, reduce the size of their executive board and be able to be much more effective in their role on campus. The club would be ableto perform at a much better standard and accomplish much more.

The system would be a mobile application which all members of the club would use. The board members would have the ability to create new content to broadcast to club members, as well as see data about club members that the board currently collects by hand. The use of a single mobile application allows for a central place to manage as many operations of the club in one easily accessible place. The application would essentially combine Slack, Google Calendars, Google Docs, and Doodle polls.By adding bits and pieces of these technologies the existing needs for these applications would disappearand allow all data to be much more easily accessibleand useable.

### Tentative Features- "how can we disseminate information"
* member profile!
    * need access code
    * ability to delete or be deleted by admin
    * check status
    * status set by exec
         * general member, active member, lead member
* Sign-in!
* Calendar!
* Polling~
* Events!
    * flag yourself as 'going'
    * event abstract/summary
* Executive chat room~
   * Schedule push notifications
* DM Officers!
* Dues notification!
* autocompiled newsletter~
* election system~
* photo gallery wall!
    * included text post/ minutes thingy
* member list!

## Document Revision History
Your first version of this document is version 1.0. After that minor changes increment the minor version number (e.g., 1.1, 1.2, …) and major changes increment the major version number and set the minor number to zero (e.g., 2.0, 3.0, …). We will follow this convention with other documents as well.

### Rev. 1.0 <YYYY-MM-DD>: initial version

## Customer
A brief description of the customer for this software, both in general (the population who might eventually use such a system) and specifically for this document (the customer(s) who informed this document). Every project is expected to find an external customer (i.e., not you). Requirements should not be derived simply from discussion among team members. Ideally your customer should not only talk to you about requirements but also be excited later in the semester to use the system.

## Competitive Landscape
Briefly identify the competitors in this market. This may need to be on a country and industry basis as the landscape varies dramatically. Any functional details about the competitive solutions should be provided. For example the known strengths or differentiating points in the competitive solutions, and also their weakness. Identifying the strengths helps ensure that we design a competitive solution; the weaknesses allow us to consider these as areas for potential differentiation. Remember there are all sorts of sources for competitive information — marketing, development, customers, the Internet, field staff, and those that we have hired from the competition — so don’t be afraid to be creative here. Note that this section may or may not be something that we want customers to see, depending on how ‘honest’ of a company as which we wish to appear. What product features can create competitive differentiators? Competitive barriers? Can a patent position be obtained in this area? What is the current patent status in this arena?

## User Requirements
This section lists the behavior that the users see. This information needs to be presented in a logical, organized fashion. It is most helpful if this section is organized in outline form: a bullet list of major topics (e.g., one for each kind of user, or each major piece of system functionality) each with some number of subtopics.

## Use Cases
Use cases that support the user requirements in the previous section. Every major scenario should be represented by a use case, and every use case should say something not already illustrated by the other use cases. Diagrams (such as sequence charts) are encouraged. Ask the customer what are the most important use cases to implement by the deadline. You can have a total ordering, or mark use cases with “must have,” “useful,” or “optional.” For each use case you may list one or more concrete acceptance tests (concrete scenarios that the customer will try to see if the use case is implemented).

## User Interface Requirements
Describes any customer user interface requirements including graphical user interface requirements as well as data exchange format requirements. This also should include necessary reporting and other forms of human readable input and output. This should focus on how the feature or product and user interact to create the desired workflow. Describing your intended interface as “easy” or “intuitive” will get you nowhere unless it is accompanied by details.

## Security Requirements
Discuss what security requirements are necessary and why. Are there privacy or confidentiality issues? Is your system vulnerable to denial-of-service attacks?

## System Requirements
List here all of the external entities, other than users, on which your system will depend. For example, if your system inter-operates with sendmail, or if you will depend on Apache for the web server, or if you must target both Unix and Windows, list those requirements here. List also memory requirements, performance/speed requirements, data capacity requirements, if applicable.

## Specification
A detailed specification of the system. Every possible execution should be in the specification, though not every aspect need be covered in extraordinary depth. UML, or other diagrams, such as finite automata, or other appropriate specification formalisms, are encouraged over natural language.
